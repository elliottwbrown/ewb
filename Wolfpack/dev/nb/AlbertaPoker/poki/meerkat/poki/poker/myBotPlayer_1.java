package poker.ai.player;import poker.Card;import poker.Deck;import poker.GameInfo;import poker.Hand;import poker.HandEvaluator;import poker.Holdem;import poker.Player;import poker.ai.ProbTriple;import poker.ai.model.WeightTable;import poker.util.Preferences;import poker.util.Randomizer;import poker.util.Reporter;import poker.GameRecord;/**  * ArodBot008 assigns a weight table to each player.  Uses * their initial preflop action and our preflop rules to * come up with probability of playing each 2-card combo. * The weight tables are used to make decisions later in the * game, but they are not updated based on later actions. *  * @author brian@chrissyandbrian.com */public class myBotPlayer extends Player {	// DONE: create own gi and fill it as we go so info is correct	// DONE: change preflop to use local gi	// DONE: change preflop to return a prob triple	// DONE: create weight table for each player (including us)	// DONE: use opponent-specific wt for decisions	// DONE: fix how we play big-blind if there is a raise	private int ID; // our position ID for the current hand	private Card c1, c2; // our hole cards	private GameInfo gi; // general game information	private Preferences prefs; // the configuration options for this bot	private HandEvaluator he = new HandEvaluator();	private Randomizer rand = new Randomizer();	private int myPreflopGroup; //preflop group	private WeightTable stdWT;	private WeightTable[] wt;		double npot = 0;    int numGamesPlayed = 0;		private GameRecord gr;	public myBotPlayer() {		stdWT = new WeightTable();		stdWT.makeStdWeightTable();		wt = new WeightTable[10];		for (int i = 0; i < 10; i++) {			wt[i] = new WeightTable();		}			}		//*****	public void update(int action, int code) {}					/**	 * Get the current settings for this bot.	 */	public Preferences getPreferences() {		return prefs;	}	/**	 * Load the current settings for this bot.	 */	public void init(Preferences playerPrefs) {		this.prefs = playerPrefs;		rand.setSeed(prefs.getIntPreference("RANDOM_SEED"));	}	/**	 * An example setting for this bot. It can be turned into	 * an always-call mode, or to a simple strategy.	 * @return true if always-call mode is active.	 *///	public boolean getAlwaysCallMode() {//		return prefs.getBooleanPreference(ALWAYS_CALL_MODE, false);//	}	/**	 * @return true if debug mode is on.	 */	public boolean getDebug() {		return prefs.getBooleanPreference("DEBUG");	}	/**	 * print a debug statement.	 */	public void debug(String str) {		if (getDebug()) {			System.out.println(str);		}	}	/**	 * print a debug statement with no end of line character	 */	public void debugb(String str) {		if (getDebug()) {			System.out.print(str);		}	}	/**	 * Start playing a new game	 * 	 * @param gInfo the current game information	 * @param c1 the first hole card	 * @param c2 the second hole card	 * @param ID the player's position	 */	public synchronized void newGame(		GameInfo gInfo,		Card c1,		Card c2,		int ID) {		this.c1 = c1;		this.c2 = c2;		this.ID = ID;		this.gi = gInfo;		myPreflopGroup = PreflopGroup.preflopGroup(c1, c2);						debug("numPlayers = " + gInfo.getNumPlayers());		debug("numGamesPlayed = " + numGamesPlayed);		numGamesPlayed++;         	}               	/**	 * Get the players next action. Uses simple probability triple generator	 * to decide	 * 	 * @return the player's action	 */	public synchronized int action() {		  		int a = Holdem.CALL;		ProbTriple pt = new ProbTriple(0, 1, 0);		double r = 0;		if (gi.getStage() == Holdem.PREFLOP) {						// if we have already acted once and someone raises behind us we will always call			if (gi.playerCommitted(ID)) {				pt.set(0, 1, 0);			} else {				pt = preFlopAction(gi, ID, myPreflopGroup);			}						    debug("Hand: [" + c1.toString() + "-" + c2.toString() + "] ");				debug("preFlopGroup=" + myPreflopGroup);						r = rand.nextDouble();			if (r < pt.getFold()) {				a = Holdem.FOLD;			} else if (r < (pt.getFold() + pt.getCall())) {				a = Holdem.CALL;			} else {				a = Holdem.RAISE;			}		} else {			a = postFlopAction();		}		if (a == Holdem.FOLD && gi.getAmountToCall(ID) == 0) {			// don't ever fold if we don't have to			a = Holdem.CALL;		} //else if (a == Holdem.RAISE && !gi.canRaise()) {//			// if we can't raise, just call//			a = Holdem.CALL;//		}		return a;	}								/**	 * Decide what to do for a pre-flop action	 */	public synchronized ProbTriple preFlopAction(		GameInfo giLocal,		int IDlocal,		int preflopGroupLocal) {					ProbTriple pt1 = new ProbTriple(.75, .15, .10);		if (giLocal.getNumPlayers() > 6) {			// NOT SHORTHANDED			//debug("Not shorthanded (6 or more)");			// IDoffset: 0 = button,  1 = small blind, 2 = big blind, etc			int IDoffset = 0;			if (IDlocal > giLocal.getButton()) {				IDoffset = IDlocal - giLocal.getButton();			} else if (IDlocal < giLocal.getButton()) {				IDoffset =					IDlocal + giLocal.getNumPlayers() - giLocal.getButton();			}			//			debug(			//				"IDlocal is "			//					+ IDlocal			//					+ ", Button is "			//					+ giLocal.getButton()			//					+ ", IDoffset is "			//					+ IDoffset);			if (((giLocal.getNumPlayers() > 6)				&& (IDoffset < 5)				&& (IDoffset > 2))				|| ((giLocal.getNumPlayers() == 6)					&& (IDoffset < 4)					&& (IDoffset > 2))) {				// EARLY POSITION				//debug("Early position (first 3 after big blind, 1st 2 if only 8 players)");				if (giLocal.getBetsToCall(IDoffset) > 2) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.02, .95, .03);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (giLocal.getBetsToCall(IDoffset) > 1) {					if (preflopGroupLocal < 3) {						// Call2						//debug("Cold call from mIDoffsetdle position: groups 1-2");						pt1.set(.02, .95, .03);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else { // no raisers, only callers if any					if (preflopGroupLocal > 4) {						//debug("Fold group 5 or greater from early position");						pt1.set(.95, .04, .01);						return pt1;					} else if (preflopGroupLocal > 2) {						//debug("Call groups 3 and 4 from early position");						pt1.set(.02, .95, .03);						return pt1;					} else {						//debug("Raise groups 1 and 2 from early position");						pt1.set(.02, .08, .90);						return pt1;					}				}			} else if (				(IDoffset == (giLocal.getNumPlayers() - 2))					|| (IDoffset == (giLocal.getNumPlayers() - 3))					|| (IDoffset == 6 && giLocal.getNumPlayers() == 10)) {				// MIDDLE POSITION				//debug("Middle position (10:6,7,8; 9:6,7; 8:5,6");				if (giLocal.getBetsToCall(IDoffset) > 2) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.02, .95, .03);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (giLocal.getBetsToCall(IDoffset) > 1) {					if (preflopGroupLocal < 3) {						// Call2						//debug("Cold call from middle position: groups 1-2");						pt1.set(.02, .95, .03);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else { // no raisers, only callers if any					if (preflopGroupLocal > 5) {						//debug("Fold group 6 or greater from middle position");						pt1.set(.95, .04, .01);						return pt1;					} else if (preflopGroupLocal > 2) {						//debug("Call groups 3 thru 5 from middle position");						pt1.set(.02, .95, .03);						return pt1;					} else {						//debug("Raise groups 1 and 2 from middle position");						pt1.set(.01, .01, .98);						return pt1;					}				}			} else if (				(IDoffset == 0)					|| (IDoffset == (giLocal.getNumPlayers() - 1))) {				// LATE POSITION				//debug("Late position (button and 1st to the right)");				if (giLocal.getBetsToCall(IDoffset) > 2) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.02, .95, .03);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (giLocal.getBetsToCall(IDoffset) > 1) {					if (preflopGroupLocal < 6) {						// Call2						//debug("Cold call from late position: groups 1-4");						pt1.set(.02, .95, .03);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else { // only callers if any					if (preflopGroupLocal < 5) {						//debug("Raise from late position: groups 1-4");						pt1.set(.05, .01, .94);						return pt1;					} else if (preflopGroupLocal > 6) {						pt1.set(.95, .04, .01);						return pt1;					} else if (						(IDoffset == 0 && giLocal.getNumActivePlayers() > 3)							|| (giLocal.getNumActivePlayers() > 4)) {						//debug("Call from late position: groups 5-6");						pt1.set(.02, .95, .03);						return pt1;					} else { // we are first to act						//debug("Steal blinds from late position: groups 5-6");						pt1.set(.20, .01, .79);						return pt1;					}				}			} else {				// LIVE BLINDS				//debug("Live blind");				if (((IDoffset == 1)					&& (giLocal.getBetsToCall(IDoffset) > 1.5))					|| ((IDoffset == 2)						&& (giLocal.getBetsToCall(IDoffset) > 1))) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.01, .79, .20);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (					((IDoffset == 1) && (giLocal.getBetsToCall(IDoffset) > .5))						|| ((IDoffset == 2)							&& (giLocal.getBetsToCall(IDoffset) > 0))) {					if (preflopGroupLocal < 3) {						// Call raiser						//debug("Call raiser from blinds: groups 1-2");						pt1.set(.01, .79, .20);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else // only callers if any					if (preflopGroupLocal < 5) {						//debug("Raise from blinds: groups 1-4");						pt1.set(.01, .02, .97);						return pt1;					} else if (preflopGroupLocal > 6) {						// don't fold if there are no bets to call (i.e. Big Blind)						if (giLocal.getAmountToCall(IDoffset) == 0) {							pt1.set(.02, .95, .03);							return pt1;						} else {							pt1.set(.95, .04, .01);							return pt1;						}					} else if (						IDoffset == 1 && giLocal.getNumActivePlayers() > 2) {						//debug("Call from small blind: groups 5-6");						pt1.set(.02, .95, .03);						return pt1;					} else if (IDoffset == 1) { // we are first to act						//debug("Steal big blind from small blind: groups 5-6");						pt1.set(.20, .01, .79);						return pt1;					} else {						//debug("Check from big blind: groups 5-6");						pt1.set(.02, .95, .03);						return pt1;					}			}		} else {			// SHORTHANDED			pt1.set(.20, .50, .30);			return pt1;		}	}	/**	* Decide what to do for a post-flop action	*/	private int postFlopAction() {		// number of players left in the hand (including us)		int np = gi.getNumActivePlayers();		// amount to call		double toCall = gi.getAmountToCall(ID);		// immediate pot odds		double PO = toCall / (double) (gi.getPot() + toCall);		// compute our current hand rank		double HRN = he.handRank(c1, c2, gi.getBoard(), np - 1);		// compute our current hand strength vs standard weight table		double HSTstd = stdWT.handStrength(c1, c2, gi.getBoard(), np - 1);		// compute our current hand strength vs each active opponent weight table		double HST = 1;		double rHST = 1;		double oppHST = 1;				rHST = HSTstd;		for (int i = 0; i < gi.getNumPlayers(); i++) {			if (gi.activePlayer(i) && i != ID) {				//oppHST = wt[i].handStrength(c1, c2, gi.getBoard());				//debug("handStregth vs. " + gi.getPlayerName(i) + " is " + oppHST);				//HST *= oppHST;				rHST *= rHST;			}		}		// compute a fast approximation of our hand potential		double PPOT = 0.0;		if (gi.getStage() < Holdem.RIVER) {			PPOT = ppot1(c1, c2, gi.getBoard());		}		//calc effective hand strength			//rHST = HST;//HST = HST + (1-HST)*PPOT;HST = rHST*(1-getLastNPot()) + (1-rHST)*PPOT;		//damping//HST = HST*(0.70);							debug(//			" | HRN = "//				+ Reporter.round(HRN, 3)//				+ " HSTstd = "//				+ Reporter.round(HSTstd, 3) + 				" rawHST = "				+ Reporter.round(rHST, 3)				+ " EffHST = "				+ Reporter.round(HST, 3)				+ " PPOT = "				+ Reporter.round(PPOT, 3)				+ " NPOT = "				+ Reporter.round(getLastNPot(), 3)//				+ " PotOdds1 = "//				+ Reporter.round(PO, 3)				+ " PotOdds = "				+ Reporter.round(((double)gi.getBetSize() / (gi.getPot() + gi.getBetSize())), 3)  );									if (HRN == 1.0) {			// dah nuts -- raise the roof!			return Holdem.RAISE;		}								//*** FLOP		if (gi.getStage() == Holdem.FLOP) {			// *** FLOP ***			// consider checking or betting:			if (toCall == 0) {				//if (rand.nextDouble() < HRN * HRN) {				if ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())					< HST) {					return Holdem.RAISE;					// bet a hand in proportion to it's strength				}				// SEMI BLUFF				if (((double) gi.getBetSize()					/ (gi.getPot() + gi.getBetSize() * 2))					< PPOT) {					// Semi-bluff: if it would be good enough to call a bet, then raise					//debug("Good enough to call a bet");					if (gi.getNumActivePlayers() < 6) {						// increases chance that everyone will fold						debug("less than six active players");						if (gi.getNumToAct() == 1) {							if (rand.nextDouble() < .25) {								debug("acting last, semibluff 25% of the time");								return Holdem.BET; // semi-bluff									} else {								debug("not acting last always semibluff");								return Holdem.BET; // semi-bluff							}						}					}				}				// just check				return Holdem.CALL;			} else {				//	consider folding, calling or raising:							//if (rand.nextDouble() < Math.pow(HRN, 1 + gi.getNumRaises())) {				if ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID))					< Math.pow(HST, 1 + gi.getNumRaises())) {					// raise in proportion to the strength of our hand					return Holdem.RAISE;				}				//if (HRN * HRN * gi.getPot() > toCall || PPOT > PO) {				if (HST * HST * gi.getPot() > toCall || PPOT > PO) {					// if we have draw odds or a strong enough hand to call					return Holdem.CALL;				}				return Holdem.FOLD;			}								// *** TURN ***				} else if (gi.getStage() == Holdem.TURN) {			// *** TURN ***			//	consider checking or betting:			if (toCall == 0) {				//if (rand.nextDouble() < HRN * HRN) {				if ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())					< HST) {					return Holdem.BET;					// bet a hand in proportion to it's strength				}				// SEMI BLUFF				if (((double) gi.getBetSize()					/ (gi.getPot() + gi.getBetSize() * 2))					< PPOT) {					// Semi-bluff: if it would be good enough to call a bet, then raise					//debug("Good enough to call a bet");					if (gi.getNumActivePlayers() < 6) {						// increases chance that everyone will fold						debug("less than six active players");						if (gi.getNumToAct() == 1) {							if (rand.nextDouble() < .25) {								debug("acting last, semibluff 25% of the time");								return Holdem.BET; // semi-bluff									} else {								debug("not acting last always semibluff");								return Holdem.BET; // semi-bluff							}						}					}				}				// just check				return Holdem.CALL;			} else {				//	consider folding, calling or raising:							//if (rand.nextDouble() < Math.pow(HRN, 1 + gi.getNumRaises())) {				if ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID))					< Math.pow(HST, 1 + gi.getNumRaises())) {					// raise in proportion to the strength of our hand					return Holdem.RAISE;				}				//if (HRN * HRN * gi.getPot() > toCall || PPOT > PO) {				if (HST * HST * gi.getPot() > toCall || PPOT > PO) {					// if we have draw odds or a strong enough hand to call					return Holdem.CALL;				}				return Holdem.FOLD;			}															//****	RIVER					} else {			// *** RIVER ***			//	consider checking or betting:			if (toCall == 0) {				//if (rand.nextDouble() < HRN * HRN) {				if ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())					< HST) {					return Holdem.BET;					// bet a hand in proportion to it's strength				}				// just check				return Holdem.CALL;			} else {				//	consider folding, calling or raising:							//if (rand.nextDouble() < Math.pow(HRN, 1 + gi.getNumRaises())) {				if ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID))					< Math.pow(HST, 1 + gi.getNumRaises())) {					// raise in proportion to the strength of our hand					return Holdem.RAISE;				}				//if (HRN * HRN * gi.getPot() > toCall || PPOT > PO) {				if (HST * HST * gi.getPot() > toCall || PPOT > PO) {					// if we have draw odds or a strong enough hand to call					return Holdem.CALL;				}				return Holdem.FOLD;			}		}	}	/**	 * Calculate the raw (unweighted) PPot1 and NPot1 of a hand. (Papp 1998, 5.3)	 * Does a one-card look ahead.	 * 	 * @param c1 the first hole card	 * @param c2 the second hole card	 * @param bd the board cards	 * @return the ppot (also sets npot not returned)	 */	public double ppot1(Card c1, Card c2, Hand bd) {		double[][] HP = new double[3][3];		double[] HPTotal = new double[3];		int ourrank7, opprank;		int index;		Hand board = new Hand(bd);		HandEvaluator HandEvaluator = new HandEvaluator();		int ourrank5 = HandEvaluator.rankHand(c1, c2, bd);		double ppot = 0;			// remove all known cards		Deck d = new Deck();		d.extractCard(c1);		d.extractCard(c2);		d.extractHand(board);		// pick first opponent card		for (int i = d.getTopCardIndex(); i < Deck.NUM_CARDS; i++) {			Card o1 = d.getCard(i);			// pick second opponent card			for (int j = i + 1; j < Deck.NUM_CARDS; j++) {				Card o2 = d.getCard(j);				opprank = HandEvaluator.rankHand(o1, o2, bd);				if (ourrank5 > opprank)					index = AHEAD;				else if (ourrank5 == opprank)					index = TIED;				else					index = BEHIND;				HPTotal[index]++;				// tally all possiblities for next board card				for (int k = d.getTopCardIndex(); k < Deck.NUM_CARDS; k++) {					if (i == k || j == k)						continue;					board.addCard(d.getCard(k));					ourrank7 = HandEvaluator.rankHand(c1, c2, board);					opprank = HandEvaluator.rankHand(o1, o2, board);					if (ourrank7 > opprank)						HP[index][AHEAD]++;					else if (ourrank7 == opprank)						HP[index][TIED]++;					else						HP[index][BEHIND]++;					board.removeCard();				}			}		} /* end of possible opponent hands */				double den1 = (45 * (HPTotal[BEHIND] + (HPTotal[TIED] / 2.0)));		double den2 = (45 * (HPTotal[AHEAD] + (HPTotal[TIED] / 2.0)));		if (den1 > 0) {			ppot =				(HP[BEHIND][AHEAD]					+ (HP[BEHIND][TIED] / 2.0)					+ (HP[TIED][AHEAD] / 2.0))					/ (double) den1;		}		if (den2 > 0) {			npot =				(HP[AHEAD][BEHIND]					+ (HP[AHEAD][TIED] / 2.0)					+ (HP[TIED][BEHIND] / 2.0))					/ (double) den2;		}		return ppot;				}	// constants used in above method:	private final static int AHEAD = 0;	private final static int TIED = 1;	private final static int BEHIND = 2;			public double getLastNPot() { return npot; }			}