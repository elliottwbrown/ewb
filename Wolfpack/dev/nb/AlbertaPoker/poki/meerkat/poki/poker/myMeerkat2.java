//import com.biotools.meerkat.*;//import com.biotools.meerkat.util.*;////import com.biotools.meerkat.Action;//import com.biotools.meerkat.Holdem;//import com.biotools.meerkat.Card;//import com.biotools.meerkat.GameInfo;//import com.biotools.meerkat.HandEvaluator;//import com.biotools.meerkat.Player;//import com.biotools.meerkat.util.Preferences;//import poker.*;//import poker.util.*;import poker.Action;import poker.Card;import poker.Deck;import poker.GameInfo;import poker.Hand;import poker.HandEvaluator;import poker.Holdem;import poker.Player;import poker.util.Preferences;import poker.util.Randomizer;import poker.*;//import poker.ai.ProbTriple;//import poker.ai.model.WeightTable;//import poker.util.Reporter;//import poker.GameRecord;//import poker.ai.Context;import java.util.*;import java.io.*;/**  * assigns a weight table to each player.  Uses * their initial preflop action and our preflop rules to * come up with probability of playing each 2-card combo. * The weight tables are used to make decisions later in the * game, but they are not updated based on later actions. *  *  */public class myMeerkat2 implements Player {	// DONE: create own gi and fill it as we go so info is correct	// DONE: change preflop to use local gi	// DONE: change preflop to return a prob triple	// DONE: create weight table for each player (including us)	// DONE: use opponent-specific wt for decisions	// DONE: fix how we play big-blind if there is a raise	public int ID; // our position ID for the current hand	public Card c1, c2; // our hole cards	public GameInfo gi; // general game information	public Preferences prefs; // the configuration options for this bot	public HandEvaluator he = new HandEvaluator();	public Randomizer rand = new Randomizer();	public int myPreflopGroup; //preflop group//	private WeightTable allOnes;//	private WeightTable[] wt;		double a = 0;	double npot = 0;	double threshold = 0.50;	double bluffThreshold = 3.0;		boolean justBluffed = false;		double tightFactor = 0;	double bluffFactor = 0;		Date startDate = new Date();	long startTime = startDate.getTime();	long now = startDate.getTime();	        int numGamesPlayed = 0;        int numPlayerThreshold = 8;        int earlyGroupThreshold = 4;        int middleGroupThreshold = 5;        int lateGroupThreshold = 6;	//	private GameRecord gr;//	private Context contxt;	public myMeerkat2() {//		allOnes = new WeightTable();//		//stdWT.makeStdWeightTable();//		wt = new WeightTable[10];//		for (int i = 0; i < 10; i++) {//			wt[i] = new WeightTable();//			wt[i].makeStdWeightTable();//		}			}					/**	 * Get the current settings for this bot.	 */	public Preferences getPreferences() {		return prefs;	}	/**	 * Load the current settings for this bot.	 */	public void init(Preferences playerPrefs) {		this.prefs = playerPrefs;		rand.setSeed(prefs.getIntPreference("RANDOM_SEED"));	}	/**	 * @return true if debug mode is on.	 */	public boolean getDebug() {		return prefs.getBooleanPreference("DEBUG");	}	/**	 * print a debug statement.	 */	public void debug(String str) {		if (getDebug()) {			System.out.println(str);		}	}	/**	 * print a debug statement with no end of line character	 */	public void debugb(String str) {		if (getDebug()) {			System.out.print(str);		}	}	/**	 * Start playing a new game	 * 	 * @param gInfo the current game information	 * @param c1 the first hole card	 * @param c2 the second hole card	 * @param ID the player's position	 */        public void gameStartEvent(GameInfo game) {		this.gi = game;	}	/**	 * Receive hole cards	 */	public void holeCards(Card card1, Card card2, int seat) {		this.c1 = card1;		this.c2 = card2;		this.ID = seat;                                                PreflopGroup pfg = new PreflopGroup();                myPreflopGroup = pfg.preflopGroup(c1, c2);			debug("numPlayers = " + gi.getNumPlayers());		debug("numGamesPlayed = " + numGamesPlayed);		numGamesPlayed++; 	}                        	        // vary aggresiveness as a cos wave over 180 minutes	public double getTightFactor() {						Date nowDate = new Date();			now = nowDate.getTime();			//get minutes passed since start			now = (now - startTime)/60000;						//System.out.println("startTime=" +startTime);			debug("***minutesPassed=" +now);						if (now>360){ //restart timer			   startTime = nowDate.getTime();			   now = 0;			}            a = now * 2.0 * 2.0 * Math.PI/360.0;            tightFactor = Math.abs(Math.cos(a));            //tightFactor = Math.cos(a));                            //System.out.println("cos(" + a + ") is " + Math.cos(a));               debug("***tightFactor=" + tightFactor);  							    return tightFactor;	 }         	/**	 * Get the players next action. Uses simple probability triple generator	 * to decide	 * 	 * @return the player's action	 */                public Action getAction() {                		int a = Holdem.CALL;		ProbTriple pt = new ProbTriple(0, 1, 0);		double r = 0;		if (gi.getStage() == Holdem.PREFLOP) {						// if we have already acted once and someone raises behind us we will always call			if (gi.playerCommitted(ID)) {				pt.set(0, 1, 0);			} else {				pt = preFlopAction(gi, ID, myPreflopGroup);			}						    debug("*****Hand: [" + c1.toString() + "-" + c2.toString() + "] ");				debug("*****preFlopGroup=" + myPreflopGroup);						r = rand.nextDouble();			if (r < pt.getFold()) {				a = Holdem.FOLD;			} else if (r < (pt.getFold() + pt.getCall())) {				a = Holdem.CALL;			} else {				a = Holdem.RAISE;			}		} else {			a = postFlopAction();		}		if (a == Holdem.FOLD && gi.getAmountToCall(ID) == 0) {			// don't ever fold if we don't have to			a = Holdem.CALL;		}                 //else if (a == Holdem.RAISE && !gi.canRaise()) {                //			// if we can't raise, just call                //			a = Holdem.CALL;                //		}                                               //translate HOLDEM object to ACTION object to fit PokerAcademy API                double toCall = gi.getAmountToCall(ID);                double toBet = gi.getBetSize();                //aCheck = Action.checkAction();                Action aCall = Action.callAction(toCall);                Action aFold = Action.foldAction(toCall);                //aBet = Action.betAction(toBet);                Action aRaise = Action.raiseAction(toCall, toBet);                                switch (a) {                    case Holdem.FOLD: return aFold;                    case Holdem.CALL: return aCall;                    case Holdem.RAISE: return aRaise;                    default: return aFold;		}		//return a;	}								/**	 * Decide what to do for a pre-flop action	 */	public synchronized ProbTriple preFlopAction(		GameInfo giLocal,		int IDlocal,		int preflopGroupLocal) {						debug("**bluffFactor = " + bluffFactor);						 if (justBluffed){		bluffFactor = 0;		justBluffed = false;		debug("Reset--bluffFactor = 0");	    }										//get tightFactor for this hand		tightFactor = getTightFactor();						//random variation of group			if (rand.nextDouble() > 0.15) {						earlyGroupThreshold=4;						middleGroupThreshold=5;						lateGroupThreshold=6;					}else{												debug("***loosePreFlop***");						earlyGroupThreshold=5;						middleGroupThreshold=6;						lateGroupThreshold=7;					}							ProbTriple pt1 = new ProbTriple(.75, .15, .10);		if (giLocal.getNumPlayers() > numPlayerThreshold) {			// NOT SHORTHANDED			//debug("Not shorthanded (8 or more)");			// IDoffset: 0 = button,  1 = small blind, 2 = big blind, etc			int IDoffset = 0;			if (IDlocal > giLocal.getButton()) {				IDoffset = IDlocal - giLocal.getButton();			} else if (IDlocal < giLocal.getButton()) {				IDoffset =					IDlocal + giLocal.getNumPlayers() - giLocal.getButton();			}			//			debug(			//				"IDlocal is "			//					+ IDlocal			//					+ ", Button is "			//					+ giLocal.getButton()			//					+ ", IDoffset is "			//					+ IDoffset);			if (((giLocal.getNumPlayers() > numPlayerThreshold)				&& (IDoffset < 6)				&& (IDoffset > 2))				|| ((giLocal.getNumPlayers() == numPlayerThreshold)					&& (IDoffset < 5)					&& (IDoffset > 2))) {				// EARLY POSITION				//debug("Early position (first 3 after big blind, 1st 2 if only 8 players)");				if (giLocal.getBetsToCall(IDoffset) > 2) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.00, .90, .10);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (giLocal.getBetsToCall(IDoffset) > 1) {					if (preflopGroupLocal < earlyGroupThreshold) {						// Call2						//debug("Cold call from mIDoffsetdle position: groups 1-2");						pt1.set(.00, .95, .05);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else { // no raisers, only callers if any					if (preflopGroupLocal > earlyGroupThreshold) {						//debug("Fold group 5 or greater from early position");						pt1.set(.95, .04, .01);						return pt1;					} else if (preflopGroupLocal > 2) {						//debug("Call groups 3 and 4 from early position");						pt1.set(.01, .95, .04);						return pt1;					} else {						//debug("Raise groups 1 and 2 from early position");						//call instead early - dont scare						//pt1.set(.02, .08, .90);						pt1.set(.00, .85, .15);						return pt1;					}				}			} else if (				(IDoffset == (giLocal.getNumPlayers() - 2))					|| (IDoffset == (giLocal.getNumPlayers() - 3))					|| (IDoffset == 6 && giLocal.getNumPlayers() == 10)) {				// MIDDLE POSITION				//debug("Middle position (10:6,7,8; 9:6,7; 8:5,6");				if (giLocal.getBetsToCall(IDoffset) > 2) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.00, .90, .10);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (giLocal.getBetsToCall(IDoffset) > 1) {					if (preflopGroupLocal < middleGroupThreshold) {						// Call2						//debug("Cold call from middle position: groups 1-2");						pt1.set(.00, .95, .05);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else { // no raisers, only callers if any					if (preflopGroupLocal > middleGroupThreshold) {						//debug("Fold group 6 or greater from middle position");						pt1.set(.95, .04, .01);						return pt1;					} else if (preflopGroupLocal > 2) {						//debug("Call groups 3 thru 5 from middle position");						pt1.set(.01, .95, .04);						return pt1;					} else {						//debug("Raise groups 1 and 2 from middle position");						//pt1.set(.01, .01, .98);						//call instead early - dont scare						pt1.set(.00, .90, .10);						return pt1;					}				}			} else if (				(IDoffset == 0)					|| (IDoffset == (giLocal.getNumPlayers() - 1))) {				// LATE POSITION				//debug("Late position (button and 1st to the right)");				if (giLocal.getBetsToCall(IDoffset) > 2) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.00, .90, .10);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (giLocal.getBetsToCall(IDoffset) > 1) {					if (preflopGroupLocal < 6) {						// Call2						//debug("Cold call from late position: groups 1-4");						pt1.set(.00, .90, .10);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else { // only callers if any					if (preflopGroupLocal < lateGroupThreshold) {						//debug("Raise from late position: groups 1-4");						pt1.set(.05, .70, .25);						return pt1;					} else if (preflopGroupLocal > lateGroupThreshold) {						pt1.set(.95, .04, .01);						return pt1;					} else if (						(IDoffset == 0 && giLocal.getNumActivePlayers() > 3)							|| (giLocal.getNumActivePlayers() > 4)) {						//debug("Call from late position: groups 5-6");						pt1.set(.01, .95, .04);						return pt1;					} else { // we are first to act						//debug("Steal blinds from late position: groups 5-6");						pt1.set(.01, .20, .79);						return pt1;					}				}			} else {				// LIVE BLINDS				debug("***Live blind***");				if (((IDoffset == 1)					&& (giLocal.getBetsToCall(IDoffset) > 1.5))					|| ((IDoffset == 2)						&& (giLocal.getBetsToCall(IDoffset) > 1))) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.00, .80, .20);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (					((IDoffset == 1) && (giLocal.getBetsToCall(IDoffset) > .5))						|| ((IDoffset == 2)							&& (giLocal.getBetsToCall(IDoffset) > 0))) {					if (preflopGroupLocal < 3) {						// Call raiser						//debug("Call raiser from blinds: groups 1-2");						pt1.set(.01, .79, .20);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else // only callers if any					if (preflopGroupLocal < middleGroupThreshold) {						//debug("Raise from blinds: groups 1-4");						pt1.set(.00, .05, .95);						return pt1;					} else if (preflopGroupLocal > lateGroupThreshold) {						// don't fold if there are no bets to call (i.e. Big Blind)						if (giLocal.getAmountToCall(IDoffset) == 0) {							pt1.set(.00, .95, .05);							return pt1;						} else {							pt1.set(.95, .04, .01);							return pt1;						}					} else if (						IDoffset == 1 && giLocal.getNumActivePlayers() > 2) {						//debug("Call from small blind: groups 5-6");						pt1.set(.01, .95, .04);						return pt1;					} else if (IDoffset == 1) { // we are first to act						//debug("Steal big blind from small blind: groups 5-6");						pt1.set(.01, .29, .70);						return pt1;					} else {						//debug("Check from big blind: groups 5-6");						pt1.set(.01, .95, .04);						return pt1;					}			}		} else {			// SHORTHANDED			pt1.set(.20, .50, .30);			return pt1;		}	}	/**	* Decide what to do for a post-flop action	*/	private int postFlopAction() {				// number of players left in the hand (including us)		int np = gi.getNumActivePlayers();		// amount to call		double toCall = gi.getAmountToCall(ID);		// immediate pot odds		double PO = toCall / (double) (gi.getPot() + toCall);		// compute our current hand rank		double HRN = he.handRank(c1, c2, gi.getBoard(), np - 1);		// compute our current hand strength vs standard weight table		//double HSTstd = stdWT.handStrength(c1, c2, gi.getBoard(), np - 1);		//double HSTstd = stdWT.handStrength(c1, c2, gi.getBoard(), np);		// compute our current hand strength vs each active opponent weight table	double HST = 1;	double oppHST = 1;	double rHST = 1;	double mHST = 1;	double dHST = 1;					for (int i = 0; i < gi.getNumPlayers(); i++) {			if (gi.activePlayer(i) && i != ID) {                            //for test comment out				//oppHST = wt[i].handStrength(c1, c2, gi.getBoard());				HST *= oppHST;			}		}//raw refrenece with dummy all ones matrix                //for test comment out//rHST = allOnes.handStrength(c1, c2, gi.getBoard());//multiplied by standard weight matrix m number of timesmHST = HST;		// compute a fast approximation of our hand potential		double PPOT = 0.0;		if (gi.getStage() < Holdem.RIVER) {			PPOT = ppot1(c1, c2, gi.getBoard());		}		        double NPOT = 0.0;        NPOT = getLastNPot();            //damped hand strength  if (gi.getStage() == Holdem.FLOP){		 //HST = HST * Math.pow(oppHST,gi.getNumRaises()+tightFactor);	 HST = HST * Math.pow(oppHST,gi.getNumRaises()+tightFactor/2);       dHST = HST;	 //HST = oppHST*oppHST*HST;	 //HST = oppHST*HST;				}else if (gi.getStage() == Holdem.TURN){		//HST = HST * Math.pow(oppHST,gi.getNumRaises()+tightFactor);	HST = HST * Math.pow(oppHST,gi.getNumRaises()+tightFactor/2);      dHST = HST;	//HST = oppHST*oppHST*HST;	//HST = oppHST*HST;					}else{		dHST = HST;	//HST = oppHST*oppHST*HST;	//HST = oppHST*HST;			}         	//debug(tightFactor + "  NUM RAISES= " + gi.getNumRaises());         //calc effective hand strength			//HST = HST + (1-HST)*PPOT;HST = HST + (1-HST)*PPOT - HST*NPOT;		//		debug(//			" | Rank = "//				+ Reporter.round(HRN, 3)//				+ " rHST = "//				+ Reporter.round(rHST, 3) //				+ " wHST = "//				+ Reporter.round(oppHST, 3)//				+ " mHST = "//				+ Reporter.round(mHST, 3)//				+ " dHST = "//				+ Reporter.round(dHST, 3)//				+ " eHST = "//				+ Reporter.round(HST, 3)//				+ " pp = "//				+ Reporter.round(PPOT, 3)//				+ " np = "//				+ Reporter.round(NPOT, 3)//				+ " *PO = "//				+ Reporter.round(PO, 3)//				+ " *fPO = "//				+ Reporter.round(((double)gi.getBetSize() / (gi.getPot() + gi.getBetSize())), 3)  );							if (HRN > 0.97) {		//if (HRN == 1.0) {			debug("***Dah Nuts -- raise the roof!");			return Holdem.RAISE;		}										//*** FLOP		if (gi.getStage() == Holdem.FLOP) {			// *** FLOP ***							if (bluffFactor>bluffThreshold){	               justBluffed=true;	               debug("!!!!!!!!!!!!!!!!!!!!!!!!!BLUFFFFFING!!!!!!!!!!!!!!!!!");                  }						// consider checking or betting:			if (toCall == 0) {				//if (rand.nextDouble() < HRN * HRN) {				if ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())					< HST) {				threshold = ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())) / HST;									debug("***FLOP_threshold= " + threshold);												if (rand.nextDouble() > threshold  || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}																		//return Holdem.CALL;					// bet a hand in proportion to it's strength				}				// SEMI BLUFF				if (((double) gi.getBetSize()					/ (gi.getPot() + gi.getBetSize() * 2))					< PPOT) {					// Semi-bluff: if it would be good enough to call a bet, then raise					//debug("Good enough to call a bet");					if (gi.getNumActivePlayers() < 5) {						// increases chance that everyone will fold						debug("less than six active players");						//if (gi.getNumToAct() == 1) {							if (rand.nextDouble() < .50) {								debug("acting last, semibluff 50% of the time");								return Holdem.BET; // semi-bluff								    } //else {//								debug("not acting last always semibluff");//								return Holdem.BET; // semi-bluff//							}						//}					}				}				// just check				return Holdem.CALL;			} else {				//	consider folding, calling or raising:							//if (rand.nextDouble() < Math.pow(HRN, 1 + gi.getNumRaises())) {				if ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID))					< Math.pow(HST, 1 + gi.getNumRaises())) {																						threshold = ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID)))  / (Math.pow(HST, 1 + gi.getNumRaises()));																					debug("***FLOP_threshold= " + threshold);																	if (rand.nextDouble() > threshold || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}												// raise in proportion to the strength of our hand					//return Holdem.RAISE;				}				//if (HRN * HRN * gi.getPot() > toCall || PPOT > PO) {				if (HST * HST * gi.getPot() > toCall || (PPOT > PO) ) {					// if we have draw odds or a strong enough hand to call					if (bluffFactor>bluffThreshold)					return Holdem.BET;					else					return Holdem.CALL;				}				return Holdem.FOLD;			}								// *** TURN ***				} else if (gi.getStage() == Holdem.TURN) {			// *** TURN ***						//debug("**Unacted: " + gi.getUnacted());						//	consider checking or betting:		if (toCall == 0) {								if(gi.getNumActivePlayers()<4 && gi.getUnacted()==1){										debug("***Bluff when others call weakly");					return Holdem.BET;									}										//if (rand.nextDouble() < HRN * HRN) {				if ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())					< HST) {									threshold = ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())) / HST;									debug("***TURN_threshold= " + threshold);												if (rand.nextDouble() > threshold || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}																		//return Holdem.BET;					// bet a hand in proportion to it's strength				}				// SEMI BLUFF				if (((double) gi.getBetSize()					/ (gi.getPot() + gi.getBetSize() * 2))					< PPOT) {					// Semi-bluff: if it would be good enough to call a bet, then raise					//debug("Good enough to call a bet");					if (gi.getNumActivePlayers() < 5) {						// increases chance that everyone will fold						debug("less than six active players");						//if (gi.getNumToAct() == 1) {							if (rand.nextDouble() < .50) {								debug("acting last, semibluff 50% of the time");								return Holdem.BET; // semi-bluff									} //else {//								debug("not acting last always semibluff");//								return Holdem.BET; // semi-bluff//							}						//}					}				}				// just check				return Holdem.CALL;			} else {								//					//added clause for high NPOT cases//			if (NPOT>0.15 && HST<0.50 && gi.getBetsToCall(ID) > 1){		//			//if (NPOT>HST){//			   debug("high negativePotential FOLD !!!!! " + gi.getBetsToCall(ID));	//			   return Holdem.FOLD;	//			}												//	consider folding, calling or raising:							//if (rand.nextDouble() < Math.pow(HRN, 1 + gi.getNumRaises())) {				if ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID))					< Math.pow(HST, 1 + gi.getNumRaises())) {																		threshold = ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID)))  / (Math.pow(HST, 1 + gi.getNumRaises()));														debug("***TURN_threshold= " + threshold);										if (rand.nextDouble() > threshold || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}																			// raise in proportion to the strength of our hand					//return Holdem.RAISE;				}				//if (HRN * HRN * gi.getPot() > toCall || PPOT > PO) {				if (HST * HST * gi.getPot() > toCall || PPOT > PO) {					// if we have draw odds or a strong enough hand to call					if (bluffFactor>bluffThreshold)					return Holdem.BET;					else					return Holdem.CALL;				}				return Holdem.FOLD;			}															//****	RIVER					} else {			// *** RIVER ***						if(HST>=0.60 && bluffFactor<3.0){			bluffFactor +=HST;			debug("****increment bluffFactor by :" + HST);			}else if (HST<0.60 && bluffFactor>-3.0){			bluffFactor -=HST;			debug("****decrement bluffFactor by :" + HST);			}												//	consider checking or betting:		if (toCall == 0) {													if(gi.getNumActivePlayers()<4 && gi.getUnacted()==1){										debug("***Bluff when others call weakly");					return Holdem.BET;									}										//if (rand.nextDouble() < HRN * HRN) {				if ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())					< HST) {												threshold = ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())) / HST;									debug("***RIVER_threshold= " + threshold);												if (rand.nextDouble() > threshold || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}																										//return Holdem.BET;					// bet a hand in proportion to it's strength				}				// just check				return Holdem.CALL;			} else {												//			if (HST<0.50 && contxt.flushPossible(5) && gi.getBetsToCall(ID) > 1){//				 debug("flush possible FOLD !!!!! " + gi.getBetsToCall(ID));//					return Holdem.FOLD;	//			}//														//added clause for high NPOT cases			//if (NPOT>HST){//		if (NPOT>0.15 && HST<0.50 && gi.getBetsToCall(ID) > 1){		//			   debug("high negativePotential FOLD !!!!! " + gi.getBetsToCall(ID));	//			   return Holdem.FOLD;	//			}												//	consider folding, calling or raising:							//if (rand.nextDouble() < Math.pow(HRN, 1 + gi.getNumRaises())) {				if ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID))					< Math.pow(HST, 1 + gi.getNumRaises())) {															threshold = ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID)))  / (Math.pow(HST, 1 + gi.getNumRaises()));															debug("***RIVER_threshold= " + threshold);											if (rand.nextDouble() > threshold || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}																			// raise in proportion to the strength of our hand					//return Holdem.RAISE;				}				//if (HRN * HRN * gi.getPot() > toCall || PPOT > PO) {				if (HST * HST * gi.getPot() > toCall || PPOT > PO) {					// if we have draw odds or a strong enough hand to call					if (bluffFactor>bluffThreshold)					return Holdem.BET;					else					return Holdem.CALL;				}				return Holdem.FOLD;			}		}	}	/**	 * Calculate the raw (unweighted) PPot1 and NPot1 of a hand. (Papp 1998, 5.3)	 * Does a one-card look ahead.	 * 	 * @param c1 the first hole card	 * @param c2 the second hole card	 * @param bd the board cards	 * @return the ppot (also sets npot not returned)	 */	public double ppot1(Card c1, Card c2, Hand bd) {		double[][] HP = new double[3][3];		double[] HPTotal = new double[3];		int ourrank7, opprank;		int index;		Hand board = new Hand(bd);		HandEvaluator HandEvaluator = new HandEvaluator();		int ourrank5 = HandEvaluator.rankHand(c1, c2, bd);		double ppot = 0;			// remove all known cards		Deck d = new Deck();		d.extractCard(c1);		d.extractCard(c2);		d.extractHand(board);		// pick first opponent card		for (int i = d.getTopCardIndex(); i < Deck.NUM_CARDS; i++) {			Card o1 = d.getCard(i);			// pick second opponent card			for (int j = i + 1; j < Deck.NUM_CARDS; j++) {				Card o2 = d.getCard(j);				opprank = HandEvaluator.rankHand(o1, o2, bd);				if (ourrank5 > opprank)					index = AHEAD;				else if (ourrank5 == opprank)					index = TIED;				else					index = BEHIND;				HPTotal[index]++;				// tally all possiblities for next board card				for (int k = d.getTopCardIndex(); k < Deck.NUM_CARDS; k++) {					if (i == k || j == k)						continue;					board.addCard(d.getCard(k));					ourrank7 = HandEvaluator.rankHand(c1, c2, board);					opprank = HandEvaluator.rankHand(o1, o2, board);					if (ourrank7 > opprank)						HP[index][AHEAD]++;					else if (ourrank7 == opprank)						HP[index][TIED]++;					else						HP[index][BEHIND]++;					board.removeCard();				}			}		} /* end of possible opponent hands */				double den1 = (45 * (HPTotal[BEHIND] + (HPTotal[TIED] / 2.0)));		double den2 = (45 * (HPTotal[AHEAD] + (HPTotal[TIED] / 2.0)));		if (den1 > 0) {			ppot =				(HP[BEHIND][AHEAD]					+ (HP[BEHIND][TIED] / 2.0)					+ (HP[TIED][AHEAD] / 2.0))					/ (double) den1;		}		if (den2 > 0) {			npot =				(HP[AHEAD][BEHIND]					+ (HP[AHEAD][TIED] / 2.0)					+ (HP[TIED][BEHIND] / 2.0))					/ (double) den2;		}		return ppot;				}                                         public class ProbTriple {       	private Randomizer rnd = new Randomizer();	private double	pf,pc,pr;		/**	 * Default constructor. Values all zero.	 */	public ProbTriple() {}		/**	 * Construct with the values given.	 * @param f fold prob	 * @param c call prob	 * @param r raise prob	 	 	 */	public ProbTriple(double f, double c, double r) {		pf = f;		pc = c;		pr = r;	}	/**	 * Set the values given.	 * @param f fold prob	 * @param c call prob	 * @param r raise prob	 	 	 */	public void set(double f, double c, double r) {		pf = f;		pc = c;		pr = r;	}	public double getFold() { return pf; }	public double getCall() { return pc; }	public double getRaise() { return pr; }	/**	 * Get the probability for an action	 * @param action FOLD/CALL/RAISE	 * @return the appropriate probability of that action	 */	public double getValue(int action) {		switch (action) {			case Holdem.FOLD: return (double)pf;			case Holdem.CALL: return (double)pc;			case Holdem.RAISE: return (double)pr;			default: return 0;		}	}	/**	 * Normalize the values in the triple to sum to 1.0	 */	public void normalize() {		double t = (pf+pc+pr);		pf = pf/t;		pc = pc/t;		pr = pr/t;			}	public boolean valid() {		double t = pf+pc+pr;      		return (t>0.99999 && t<1.00001);	}		/**	 * Add the values of one triple into this one.	 */		public  void add(ProbTriple pt) {		this.pf = this.pf + pt.getFold();		this.pc = this.pc + pt.getCall();		this.pr = this.pr + pt.getRaise();	}	/**	 * Add the values of one triple into this one.	 */		public void dotProduct(ProbTriple pt) {		pf *= pt.pf;		pc *= pt.pc;		pr *= pt.pr;					}		/**	 * Multiply all entries by a constant.	 * @param val to multiply the values.	 */	public void weight(double val) {		pf *= val;		pc *= val;		pr *= val;	}	public void setFold(double f) { this.pf = f; }	public void setCall(double c) { this.pc = c; }	public void setRaise(double r) { this.pr = r; }	/**	 * Select an action from the triple distribution.	 * @param spin a random value indexing into the triple.	 * @param useMax take one of the maximum values in the triple.	 */	public int select(double spin, boolean useMax) {		if (useMax) return selectMax(spin);		return select(spin);	}	/**	 * Select an action from the triple using the given spinner.	 * @param spin A random number between 0 and 1	 */	public int select(double spin) {        	if (spin < pf) return Holdem.FOLD;                else if (spin < pf+pc) 			return Holdem.CALL;                else 			return Holdem.RAISE;	}			/**	 * Select the maximum value.	 * @param spin A random number between 0 and 1	 	 */	public int selectMax(double spin) {		if (pf > pc && pf > pr) return Holdem.FOLD;		if (pc > pf && pc > pr) return Holdem.CALL;		if (pr > pf && pr > pc) return Holdem.RAISE;		if (pr > pf && pr == pc) return (spin > 0.5 ? Holdem.CALL : Holdem.RAISE);		if (pc > pr && pc == pf) return (spin > 0.5 ? Holdem.FOLD : Holdem.CALL);		if (pr > pc && pr == pf) return (spin > 0.5 ? Holdem.FOLD : Holdem.RAISE);		return Holdem.CALL;	}		/**	 * Select the maximum value.	 */	public int selectMax() {		return selectMax(rnd.nextDouble());	}	/**	 * Randomly select an action from the triple.	 */	public int select() {		return select(rnd.nextDouble());	}	public String toString() {		return new String("{"+round((double)pf,3)+", "+round((double)pc,3)+", "+round((double)pr,3)+"}");	}	private double round(double f, int precision) {		double n = 1;		for (int i=0;i<precision;i++) n*=10;		return java.lang.Math.round(f*n)/n;	}}          public class PreflopGroup {          	public int preflopGroup(Card c1, Card c2) {		// classify hole cards into a preflop group		// Group 1	AA, KK, QQ, JJ, AKs		// Group 2	TT, AQs, AJs, KQs, AK		// Group 3	99, JTs, QJs, KJs, ATs, AQ		// Group 4	T9s, KQ, 88, QTs, 98s, J9s, AJ, KTs		// Group 5	77, 87s, Q9s, T8s, KJ, QJ, JT, 76s, 97S, Axs, 65s		// Group 6	66, AT, 55, 86s, KT, QT, 54s, K9s, J8s, 75s		// Group 7	44, J9, 64s, T9, 53s, 33, 98, 43s, 22, Kxs, T7s, Q8s		// Group 8	87, A9, Q9, 76, 42s, 32s, 96s, 85s, J8, J7s, 65, 54, 74s, K9, T8		// assume the worst		int group = 9;		int c1Rank = c1.getRank();		int c2Rank = c2.getRank();		int tmpRank = 0;				if ( c1Rank < c2Rank ) {			tmpRank = c2Rank;			c2Rank = c1Rank;			c1Rank = tmpRank;		}		System.out.println(" -------> Assigning hand to a preflop group");		// do we have a pair		if (c1Rank == c2Rank) {			switch (c1Rank) {				case Card.ACE :					{						group = 1;						break;					}				case Card.KING :					{						group = 1;						break;					}				case Card.QUEEN :					{						group = 1;						break;					}				case Card.JACK :					{						group = 1;						break;					}				case Card.TEN :					{						group = 2;						break;					}				case Card.NINE :					{						group = 3;						break;					}				case Card.EIGHT :					{						group = 4;						break;					}				case Card.SEVEN :					{						group = 5;						break;					}				case Card.SIX :					{						group = 6;						break;					}				case Card.FIVE :					{						group = 6;						break;					}				default :					{						group = 7;						break;					}			}		} else { //no pair			// suited?			if (c1.getSuit() == c2.getSuit()) {				switch (c1Rank) {					case Card.ACE :						{							switch (c2Rank) {								case Card.KING :									{										group = 1;										break;									}								case Card.QUEEN :									{										group = 2;										break;									}								case Card.JACK :									{										group = 2;										break;									}								case Card.TEN :									{										group = 3;										break;									}								default :									{										group = 5;										break;									}							}							break;						}					case Card.KING :						{							switch (c2Rank) {								case Card.QUEEN :									{										group = 2;										break;									}								case Card.JACK :									{										group = 3;										break;									}								case Card.TEN :									{										group = 4;										break;									}								case Card.NINE :									{										group = 6;										break;									}								default :									{										group = 7;										break;									}							}							break;						}					case Card.QUEEN :						{							switch (c2Rank) {								case Card.JACK :									{										group = 3;										break;									}								case Card.TEN :									{										group = 4;										break;									}								case Card.NINE :									{										group = 5;										break;									}								case Card.EIGHT :									{										group = 7;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.JACK :						{							switch (c2Rank) {								case Card.TEN :									{										group = 3;										break;									}								case Card.NINE :									{										group = 4;										break;									}								case Card.EIGHT :									{										group = 6;										break;									}								case Card.SEVEN :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.TEN :						{							switch (c2Rank) {								case Card.NINE :									{										group = 4;										break;									}								case Card.EIGHT :									{										group = 5;										break;									}								case Card.SEVEN :									{										group = 7;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.NINE :						{							switch (c2Rank) {								case Card.EIGHT :									{										group = 4;										break;									}								case Card.SEVEN :									{										group = 5;										break;									}								case Card.SIX :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.EIGHT :						{							switch (c2Rank) {								case Card.SEVEN :									{										group = 5;										break;									}								case Card.SIX :									{										group = 6;										break;									}								case Card.FIVE :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.SEVEN :						{							switch (c2Rank) {								case Card.SIX :									{										group = 5;										break;									}								case Card.FIVE :									{										group = 6;										break;									}								case Card.FOUR :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.SIX :						{							switch (c2Rank) {								case Card.FIVE :									{										group = 5;										break;									}								case Card.FOUR :									{										group = 7;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.FIVE :						{							switch (c2Rank) {								case Card.FOUR :									{										group = 6;										break;									}								case Card.THREE :									{										group = 7;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.FOUR :						{							switch (c2Rank) {								case Card.THREE :									{										group = 7;										break;									}								case Card.TWO :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.THREE :						{							switch (c2Rank) {								case Card.TWO :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}				}			} else { // not suited				switch (c1Rank) {					case Card.ACE :						{							switch (c2Rank) {								case Card.KING :									{										group = 2;										break;									}								case Card.QUEEN :									{										group = 3;										break;									}								case Card.JACK :									{										group = 4;										break;									}								case Card.TEN :									{										group = 6;										break;									}								case Card.NINE :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.KING :						{							switch (c2Rank) {								case Card.QUEEN :									{										group = 4;										break;									}								case Card.JACK :									{										group = 5;										break;									}								case Card.TEN :									{										group = 6;										break;									}								case Card.NINE :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.QUEEN :						{							switch (c2Rank) {								case Card.JACK :									{										group = 5;										break;									}								case Card.TEN :									{										group = 6;										break;									}								case Card.NINE :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.JACK :						{							switch (c2Rank) {								case Card.TEN :									{										group = 5;										break;									}								case Card.NINE :									{										group = 7;										break;									}								case Card.EIGHT :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.TEN :						{							switch (c2Rank) {								case Card.NINE :									{										group = 7;										break;									}								case Card.EIGHT :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.NINE :						{							switch (c2Rank) {								case Card.EIGHT :									{										group = 7;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.EIGHT :						{							switch (c2Rank) {								case Card.SEVEN :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.SEVEN :						{							switch (c2Rank) {								case Card.SIX :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.SIX :						{							switch (c2Rank) {								case Card.FIVE :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}					case Card.FIVE :						{							switch (c2Rank) {								case Card.FOUR :									{										group = 8;										break;									}								default :									{										group = 9;										break;									}							}							break;						}				}			}		}		//System.out.println(" -------> Preflop group is " + Integer.toString(group));		return group;	}}                                        	// constants used in above method:	private final static int AHEAD = 0;	private final static int TIED = 1;	private final static int BEHIND = 2;			public double getLastNPot() { return npot; }	    /**    * A new betting round has started.    */    public void stageEvent(int stage) {}   /**    * A showdown has occurred.    * @param pos the position of the player showing    * @param c1 the first hole card shown    * @param c2 the second hole card shown    */   public void showdownEvent(int seat, Card c1, Card c2) {}   /**    * An action has been observed.     */   public void actionEvent(int pos, Action act) { }      /**    * The game info state has been updated    * Called after an action event has been fully processed    */   public void gameStateChanged() {}     /**    * The hand is now over.     */   public void gameOverEvent() {}   /**    * A player at pos has won amount with the hand handName    */   public void winEvent(int pos, double amount, String handName) {}               }