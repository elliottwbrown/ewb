package poker.ai.player;import poker.Card;import poker.Deck;import poker.GameInfo;import poker.Hand;import poker.HandEvaluator;import poker.Holdem;import poker.Player;import poker.ai.ProbTriple;import poker.ai.Context;import poker.ai.model.WeightTable;import poker.util.Preferences;import poker.util.Randomizer;import poker.util.Reporter;import poker.GameRecord;import java.util.Date;//import com.biotools.meerkat.Action;////import com.biotools.meerkat.Card;//import com.biotools.meerkat.Deck;//import com.biotools.meerkat.Hand;//import com.biotools.meerkat.Holdem;//import com.biotools.meerkat.GameInfo;//import com.biotools.meerkat.HandEvaluator;//import com.biotools.meerkat.Player;//import com.biotools.meerkat.util.Preferences;//import com.biotools.meerkat.util.Randomizer;/**  * assigns a weight table to each player.  Uses * their initial preflop action and our preflop rules to * come up with probability of playing each 2-card combo. * The weight tables are used to make decisions later in the * game, but they are not updated based on later actions. *  *  */public class myMeerkat extends Player {	// DONE: create own gi and fill it as we go so info is correct	// DONE: change preflop to use local gi	// DONE: change preflop to return a prob triple	// DONE: create weight table for each player (including us)	// DONE: use opponent-specific wt for decisions	// DONE: fix how we play big-blind if there is a raise	private int ID; // our position ID for the current hand	private Card c1, c2; // our hole cards	private GameInfo m;     	/**	 * Get the players next action. Uses simple probability triple generator	 * to decide	 * 	 * @return the player's action	 */	public synchronized int action() {		  		int a = Holdem.CALL;		ProbTriple pt = new ProbTriple(0, 1, 0);		double r = 0;		if (gi.getStage() == Holdem.PREFLOP) {						// if we have already acted once and someone raises behind us we will always call			if (gi.playerCommitted(ID)) {				pt.set(0, 1, 0);			} else {				pt = preFlopAction(gi, ID, myPreflopGroup);			}						    debug("*****Hand: [" + c1.toString() + "-" + c2.toString() + "] ");				debug("*****preFlopGroup=" + myPreflopGroup);						r = rand.nextDouble();			if (r < pt.getFold()) {				a = Holdem.FOLD;			} else if (r < (pt.getFold() + pt.getCall())) {				a = Holdem.CALL;			} else {				a = Holdem.RAISE;			}		} else {			a = postFlopAction();		}		if (a == Holdem.FOLD && gi.getAmountToCall(ID) == 0) {			// don't ever fold if we don't have to			a = Holdem.CALL;		} //else if (a == Holdem.RAISE && !gi.canRaise()) {//			// if we can't raise, just call//			a = Holdem.CALL;//		}		return a;	}								/**	 * Decide what to do for a pre-flop action	 */	public synchronized ProbTriple preFlopAction(		GameInfo giLocal,		int IDlocal,		int preflopGroupLocal) {						debug("**bluffFactor = " + bluffFactor);						 if (justBluffed){		bluffFactor = 0;		justBluffed = false;		debug("Reset--bluffFactor = 0");	    }										//get tightFactor for this hand		tightFactor = getTightFactor();						//random variation of group			if (rand.nextDouble() > 0.15) {						earlyGroupThreshold=4;						middleGroupThreshold=5;						lateGroupThreshold=6;					}else{												debug("***loosePreFlop***");						earlyGroupThreshold=5;						middleGroupThreshold=6;						lateGroupThreshold=7;					}							ProbTriple pt1 = new ProbTriple(.75, .15, .10);		if (giLocal.getNumPlayers() > numPlayerThreshold) {			// NOT SHORTHANDED			//debug("Not shorthanded (8 or more)");			// IDoffset: 0 = button,  1 = small blind, 2 = big blind, etc			int IDoffset = 0;			if (IDlocal > giLocal.getButton()) {				IDoffset = IDlocal - giLocal.getButton();			} else if (IDlocal < giLocal.getButton()) {				IDoffset =					IDlocal + giLocal.getNumPlayers() - giLocal.getButton();			}			//			debug(			//				"IDlocal is "			//					+ IDlocal			//					+ ", Button is "			//					+ giLocal.getButton()			//					+ ", IDoffset is "			//					+ IDoffset);			if (((giLocal.getNumPlayers() > numPlayerThreshold)				&& (IDoffset < 6)				&& (IDoffset > 2))				|| ((giLocal.getNumPlayers() == numPlayerThreshold)					&& (IDoffset < 5)					&& (IDoffset > 2))) {				// EARLY POSITION				//debug("Early position (first 3 after big blind, 1st 2 if only 8 players)");				if (giLocal.getBetsToCall(IDoffset) > 2) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.00, .90, .10);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (giLocal.getBetsToCall(IDoffset) > 1) {					if (preflopGroupLocal < earlyGroupThreshold) {						// Call2						//debug("Cold call from mIDoffsetdle position: groups 1-2");						pt1.set(.00, .95, .05);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else { // no raisers, only callers if any					if (preflopGroupLocal > earlyGroupThreshold) {						//debug("Fold group 5 or greater from early position");						pt1.set(.95, .04, .01);						return pt1;					} else if (preflopGroupLocal > 2) {						//debug("Call groups 3 and 4 from early position");						pt1.set(.01, .95, .04);						return pt1;					} else {						//debug("Raise groups 1 and 2 from early position");						//call instead early - dont scare						//pt1.set(.02, .08, .90);						pt1.set(.00, .85, .15);						return pt1;					}				}			} else if (				(IDoffset == (giLocal.getNumPlayers() - 2))					|| (IDoffset == (giLocal.getNumPlayers() - 3))					|| (IDoffset == 6 && giLocal.getNumPlayers() == 10)) {				// MIDDLE POSITION				//debug("Middle position (10:6,7,8; 9:6,7; 8:5,6");				if (giLocal.getBetsToCall(IDoffset) > 2) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.00, .90, .10);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (giLocal.getBetsToCall(IDoffset) > 1) {					if (preflopGroupLocal < middleGroupThreshold) {						// Call2						//debug("Cold call from middle position: groups 1-2");						pt1.set(.00, .95, .05);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else { // no raisers, only callers if any					if (preflopGroupLocal > middleGroupThreshold) {						//debug("Fold group 6 or greater from middle position");						pt1.set(.95, .04, .01);						return pt1;					} else if (preflopGroupLocal > 2) {						//debug("Call groups 3 thru 5 from middle position");						pt1.set(.01, .95, .04);						return pt1;					} else {						//debug("Raise groups 1 and 2 from middle position");						//pt1.set(.01, .01, .98);						//call instead early - dont scare						pt1.set(.00, .90, .10);						return pt1;					}				}			} else if (				(IDoffset == 0)					|| (IDoffset == (giLocal.getNumPlayers() - 1))) {				// LATE POSITION				//debug("Late position (button and 1st to the right)");				if (giLocal.getBetsToCall(IDoffset) > 2) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.00, .90, .10);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (giLocal.getBetsToCall(IDoffset) > 1) {					if (preflopGroupLocal < 6) {						// Call2						//debug("Cold call from late position: groups 1-4");						pt1.set(.00, .90, .10);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else { // only callers if any					if (preflopGroupLocal < lateGroupThreshold) {						//debug("Raise from late position: groups 1-4");						pt1.set(.05, .70, .25);						return pt1;					} else if (preflopGroupLocal > lateGroupThreshold) {						pt1.set(.95, .04, .01);						return pt1;					} else if (						(IDoffset == 0 && giLocal.getNumActivePlayers() > 3)							|| (giLocal.getNumActivePlayers() > 4)) {						//debug("Call from late position: groups 5-6");						pt1.set(.01, .95, .04);						return pt1;					} else { // we are first to act						//debug("Steal blinds from late position: groups 5-6");						pt1.set(.01, .20, .79);						return pt1;					}				}			} else {				// LIVE BLINDS				debug("***Live blind***");				if (((IDoffset == 1)					&& (giLocal.getBetsToCall(IDoffset) > 1.5))					|| ((IDoffset == 2)						&& (giLocal.getBetsToCall(IDoffset) > 1))) {					if (preflopGroupLocal == 1) {						//Call any						pt1.set(.00, .80, .20);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else if (					((IDoffset == 1) && (giLocal.getBetsToCall(IDoffset) > .5))						|| ((IDoffset == 2)							&& (giLocal.getBetsToCall(IDoffset) > 0))) {					if (preflopGroupLocal < 3) {						// Call raiser						//debug("Call raiser from blinds: groups 1-2");						pt1.set(.01, .79, .20);						return pt1;					} else {						pt1.set(.95, .04, .01);						return pt1;					}				} else // only callers if any					if (preflopGroupLocal < middleGroupThreshold) {						//debug("Raise from blinds: groups 1-4");						pt1.set(.00, .05, .95);						return pt1;					} else if (preflopGroupLocal > lateGroupThreshold) {						// don't fold if there are no bets to call (i.e. Big Blind)						if (giLocal.getAmountToCall(IDoffset) == 0) {							pt1.set(.00, .95, .05);							return pt1;						} else {							pt1.set(.95, .04, .01);							return pt1;						}					} else if (						IDoffset == 1 && giLocal.getNumActivePlayers() > 2) {						//debug("Call from small blind: groups 5-6");						pt1.set(.01, .95, .04);						return pt1;					} else if (IDoffset == 1) { // we are first to act						//debug("Steal big blind from small blind: groups 5-6");						pt1.set(.01, .29, .70);						return pt1;					} else {						//debug("Check from big blind: groups 5-6");						pt1.set(.01, .95, .04);						return pt1;					}			}		} else {			// SHORTHANDED			pt1.set(.20, .50, .30);			return pt1;		}	}	/**	* Decide what to do for a post-flop action	*/	private int postFlopAction() {				// number of players left in the hand (including us)		int np = gi.getNumActivePlayers();		// amount to call		double toCall = gi.getAmountToCall(ID);		// immediate pot odds		double PO = toCall / (double) (gi.getPot() + toCall);		// compute our current hand rank		double HRN = he.handRank(c1, c2, gi.getBoard(), np - 1);		// compute our current hand strength vs standard weight table		//double HSTstd = stdWT.handStrength(c1, c2, gi.getBoard(), np - 1);		//double HSTstd = stdWT.handStrength(c1, c2, gi.getBoard(), np);		// compute our current hand strength vs each active opponent weight table	double HST = 1;	double oppHST = 1;	double rHST = 1;	double mHST = 1;	double dHST = 1;					for (int i = 0; i < gi.getNumPlayers(); i++) {			if (gi.activePlayer(i) && i != ID) {				oppHST = wt[i].handStrength(c1, c2, gi.getBoard());				HST *= oppHST;			}		}//raw refrenece with dummy all ones matrixrHST = allOnes.handStrength(c1, c2, gi.getBoard());//multiplied by standard weight matrix m number of timesmHST = HST;		// compute a fast approximation of our hand potential		double PPOT = 0.0;		if (gi.getStage() < Holdem.RIVER) {			PPOT = ppot1(c1, c2, gi.getBoard());		}		        double NPOT = 0.0;        NPOT = getLastNPot();            //damped hand strength  if (gi.getStage() == Holdem.FLOP){		 //HST = HST * Math.pow(oppHST,gi.getNumRaises()+tightFactor);	 HST = HST * Math.pow(oppHST,gi.getNumRaises()+tightFactor/2);       dHST = HST;	 //HST = oppHST*oppHST*HST;	 //HST = oppHST*HST;				}else if (gi.getStage() == Holdem.TURN){		//HST = HST * Math.pow(oppHST,gi.getNumRaises()+tightFactor);	HST = HST * Math.pow(oppHST,gi.getNumRaises()+tightFactor/2);      dHST = HST;	//HST = oppHST*oppHST*HST;	//HST = oppHST*HST;					}else{		dHST = HST;	//HST = oppHST*oppHST*HST;	//HST = oppHST*HST;			}         	//debug(tightFactor + "  NUM RAISES= " + gi.getNumRaises());         //calc effective hand strength			//HST = HST + (1-HST)*PPOT;HST = HST + (1-HST)*PPOT - HST*NPOT;		//		debug(//			" | Rank = "//				+ Reporter.round(HRN, 3)//				+ " rHST = "//				+ Reporter.round(rHST, 3) //				+ " wHST = "//				+ Reporter.round(oppHST, 3)//				+ " mHST = "//				+ Reporter.round(mHST, 3)//				+ " dHST = "//				+ Reporter.round(dHST, 3)//				+ " eHST = "//				+ Reporter.round(HST, 3)//				+ " pp = "//				+ Reporter.round(PPOT, 3)//				+ " np = "//				+ Reporter.round(NPOT, 3)//				+ " *PO = "//				+ Reporter.round(PO, 3)//				+ " *fPO = "//				+ Reporter.round(((double)gi.getBetSize() / (gi.getPot() + gi.getBetSize())), 3)  );							if (HRN > 0.97) {		//if (HRN == 1.0) {			debug("***Dah Nuts -- raise the roof!");			return Holdem.RAISE;		}										//*** FLOP		if (gi.getStage() == Holdem.FLOP) {			// *** FLOP ***							if (bluffFactor>bluffThreshold){	               justBluffed=true;	               debug("!!!!!!!!!!!!!!!!!!!!!!!!!BLUFFFFFING!!!!!!!!!!!!!!!!!");                  }						// consider checking or betting:			if (toCall == 0) {				//if (rand.nextDouble() < HRN * HRN) {				if ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())					< HST) {				threshold = ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())) / HST;									debug("***FLOP_threshold= " + threshold);												if (rand.nextDouble() > threshold  || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}																		//return Holdem.CALL;					// bet a hand in proportion to it's strength				}				// SEMI BLUFF				if (((double) gi.getBetSize()					/ (gi.getPot() + gi.getBetSize() * 2))					< PPOT) {					// Semi-bluff: if it would be good enough to call a bet, then raise					//debug("Good enough to call a bet");					if (gi.getNumActivePlayers() < 5) {						// increases chance that everyone will fold						debug("less than six active players");						//if (gi.getNumToAct() == 1) {							if (rand.nextDouble() < .50) {								debug("acting last, semibluff 50% of the time");								return Holdem.BET; // semi-bluff								    } //else {//								debug("not acting last always semibluff");//								return Holdem.BET; // semi-bluff//							}						//}					}				}				// just check				return Holdem.CALL;			} else {				//	consider folding, calling or raising:							//if (rand.nextDouble() < Math.pow(HRN, 1 + gi.getNumRaises())) {				if ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID))					< Math.pow(HST, 1 + gi.getNumRaises())) {																						threshold = ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID)))  / (Math.pow(HST, 1 + gi.getNumRaises()));																					debug("***FLOP_threshold= " + threshold);																	if (rand.nextDouble() > threshold || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}												// raise in proportion to the strength of our hand					//return Holdem.RAISE;				}				//if (HRN * HRN * gi.getPot() > toCall || PPOT > PO) {				if (HST * HST * gi.getPot() > toCall || (PPOT > PO) ) {					// if we have draw odds or a strong enough hand to call					if (bluffFactor>bluffThreshold)					return Holdem.BET;					else					return Holdem.CALL;				}				return Holdem.FOLD;			}								// *** TURN ***				} else if (gi.getStage() == Holdem.TURN) {			// *** TURN ***						//debug("**Unacted: " + gi.getUnacted());						//	consider checking or betting:		if (toCall == 0) {								if(gi.getNumActivePlayers()<4 && gi.getUnacted()==1){										debug("***Bluff when others call weakly");					return Holdem.BET;									}										//if (rand.nextDouble() < HRN * HRN) {				if ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())					< HST) {									threshold = ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())) / HST;									debug("***TURN_threshold= " + threshold);												if (rand.nextDouble() > threshold || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}																		//return Holdem.BET;					// bet a hand in proportion to it's strength				}				// SEMI BLUFF				if (((double) gi.getBetSize()					/ (gi.getPot() + gi.getBetSize() * 2))					< PPOT) {					// Semi-bluff: if it would be good enough to call a bet, then raise					//debug("Good enough to call a bet");					if (gi.getNumActivePlayers() < 5) {						// increases chance that everyone will fold						debug("less than six active players");						//if (gi.getNumToAct() == 1) {							if (rand.nextDouble() < .50) {								debug("acting last, semibluff 50% of the time");								return Holdem.BET; // semi-bluff									} //else {//								debug("not acting last always semibluff");//								return Holdem.BET; // semi-bluff//							}						//}					}				}				// just check				return Holdem.CALL;			} else {								//					//added clause for high NPOT cases//			if (NPOT>0.15 && HST<0.50 && gi.getBetsToCall(ID) > 1){		//			//if (NPOT>HST){//			   debug("high negativePotential FOLD !!!!! " + gi.getBetsToCall(ID));	//			   return Holdem.FOLD;	//			}												//	consider folding, calling or raising:							//if (rand.nextDouble() < Math.pow(HRN, 1 + gi.getNumRaises())) {				if ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID))					< Math.pow(HST, 1 + gi.getNumRaises())) {																		threshold = ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID)))  / (Math.pow(HST, 1 + gi.getNumRaises()));														debug("***TURN_threshold= " + threshold);										if (rand.nextDouble() > threshold || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}																			// raise in proportion to the strength of our hand					//return Holdem.RAISE;				}				//if (HRN * HRN * gi.getPot() > toCall || PPOT > PO) {				if (HST * HST * gi.getPot() > toCall || PPOT > PO) {					// if we have draw odds or a strong enough hand to call					if (bluffFactor>bluffThreshold)					return Holdem.BET;					else					return Holdem.CALL;				}				return Holdem.FOLD;			}															//****	RIVER					} else {			// *** RIVER ***						if(HST>=0.60 && bluffFactor<3.0){			bluffFactor +=HST;			debug("****increment bluffFactor by :" + HST);			}else if (HST<0.60 && bluffFactor>-3.0){			bluffFactor -=HST;			debug("****decrement bluffFactor by :" + HST);			}												//	consider checking or betting:		if (toCall == 0) {													if(gi.getNumActivePlayers()<4 && gi.getUnacted()==1){										debug("***Bluff when others call weakly");					return Holdem.BET;									}										//if (rand.nextDouble() < HRN * HRN) {				if ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())					< HST) {												threshold = ((double) gi.getBetSize() / (gi.getPot() + gi.getBetSize())) / HST;									debug("***RIVER_threshold= " + threshold);												if (rand.nextDouble() > threshold || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}																										//return Holdem.BET;					// bet a hand in proportion to it's strength				}				// just check				return Holdem.CALL;			} else {												//			if (HST<0.50 && contxt.flushPossible(5) && gi.getBetsToCall(ID) > 1){//				 debug("flush possible FOLD !!!!! " + gi.getBetsToCall(ID));//					return Holdem.FOLD;	//			}//														//added clause for high NPOT cases			//if (NPOT>HST){//		if (NPOT>0.15 && HST<0.50 && gi.getBetsToCall(ID) > 1){		//			   debug("high negativePotential FOLD !!!!! " + gi.getBetsToCall(ID));	//			   return Holdem.FOLD;	//			}												//	consider folding, calling or raising:							//if (rand.nextDouble() < Math.pow(HRN, 1 + gi.getNumRaises())) {				if ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID))					< Math.pow(HST, 1 + gi.getNumRaises())) {															threshold = ((double) (gi.getBetSize() + gi.getAmountToCall(ID))					/ (gi.getPot() + gi.getBetSize() + gi.getAmountToCall(ID)))  / (Math.pow(HST, 1 + gi.getNumRaises()));															debug("***RIVER_threshold= " + threshold);											if (rand.nextDouble() > threshold || bluffFactor>bluffThreshold) {						return Holdem.BET;					}else{						return Holdem.CALL;					}																			// raise in proportion to the strength of our hand					//return Holdem.RAISE;				}				//if (HRN * HRN * gi.getPot() > toCall || PPOT > PO) {				if (HST * HST * gi.getPot() > toCall || PPOT > PO) {					// if we have draw odds or a strong enough hand to call					if (bluffFactor>bluffThreshold)					return Holdem.BET;					else					return Holdem.CALL;				}				return Holdem.FOLD;			}		}	}	/**	 * Calculate the raw (unweighted) PPot1 and NPot1 of a hand. (Papp 1998, 5.3)	 * Does a one-card look ahead.	 * 	 * @param c1 the first hole card	 * @param c2 the second hole card	 * @param bd the board cards	 * @return the ppot (also sets npot not returned)	 */	public double ppot1(Card c1, Card c2, Hand bd) {		double[][] HP = new double[3][3];		double[] HPTotal = new double[3];		int ourrank7, opprank;		int index;		Hand board = new Hand(bd);		HandEvaluator HandEvaluator = new HandEvaluator();		int ourrank5 = HandEvaluator.rankHand(c1, c2, bd);		double ppot = 0;			// remove all known cards		Deck d = new Deck();		d.extractCard(c1);		d.extractCard(c2);		d.extractHand(board);		// pick first opponent card		for (int i = d.getTopCardIndex(); i < Deck.NUM_CARDS; i++) {			Card o1 = d.getCard(i);			// pick second opponent card			for (int j = i + 1; j < Deck.NUM_CARDS; j++) {				Card o2 = d.getCard(j);				opprank = HandEvaluator.rankHand(o1, o2, bd);				if (ourrank5 > opprank)					index = AHEAD;				else if (ourrank5 == opprank)					index = TIED;				else					index = BEHIND;				HPTotal[index]++;				// tally all possiblities for next board card				for (int k = d.getTopCardIndex(); k < Deck.NUM_CARDS; k++) {					if (i == k || j == k)						continue;					board.addCard(d.getCard(k));					ourrank7 = HandEvaluator.rankHand(c1, c2, board);					opprank = HandEvaluator.rankHand(o1, o2, board);					if (ourrank7 > opprank)						HP[index][AHEAD]++;					else if (ourrank7 == opprank)						HP[index][TIED]++;					else						HP[index][BEHIND]++;					board.removeCard();				}			}		} /* end of possible opponent hands */				double den1 = (45 * (HPTotal[BEHIND] + (HPTotal[TIED] / 2.0)));		double den2 = (45 * (HPTotal[AHEAD] + (HPTotal[TIED] / 2.0)));		if (den1 > 0) {			ppot =				(HP[BEHIND][AHEAD]					+ (HP[BEHIND][TIED] / 2.0)					+ (HP[TIED][AHEAD] / 2.0))					/ (double) den1;		}		if (den2 > 0) {			npot =				(HP[AHEAD][BEHIND]					+ (HP[AHEAD][TIED] / 2.0)					+ (HP[TIED][BEHIND] / 2.0))					/ (double) den2;		}		return ppot;				}	// constants used in above method:	private final static int AHEAD = 0;	private final static int TIED = 1;	private final static int BEHIND = 2;			public double getLastNPot() { return npot; }			}